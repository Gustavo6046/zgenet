#include "zgenet.zsc"

class GeneZombieAgent : NNAgent {
    GeneZombie MyZombie;
    int age;

    static GeneZombieAgent Make(GeneZombie owner) {
        GeneZombieAgent agent = GeneZombieAgent(Spawn("GeneZombieAgent"));
    
        agent.MyZombie = owner;

        return agent;
    }

    //=====

    override void refreshInputs(NeuralNetwork net) {
        net.inputs[0] = MyZombie.health * NeuralNetwork.FIXUNIT / MyZombie.SpawnHealth();

        double ageval = age;
        ageval /= 80.0;

        // oscillator neurons
        net.inputs[8] = sin(ageval) * NeuralNetwork.FIXUNIT;
        net.inputs[9] = sin(ageval / 8) * NeuralNetwork.FIXUNIT;

        // am firing?
        net.inputs[15] = (MyZombie.firing ? NeuralNetwork.FIXUNIT : 0);
        
        if (MyZombie.target == null) {
            net.inputs[1] = 0;

            net.inputs[2] = 0;
            net.inputs[3] = 0;

            net.inputs[4] = 0;
            net.inputs[12] = 0;

            net.inputs[5] = 0;
            net.inputs[6] = 0;

            net.inputs[7] = 0;

            net.inputs[10] = 0;
            net.inputs[11] = 0;
        }

        else {
            Vector2 enemyOffs = MyZombie.Vec2To(MyZombie.target);
            double toEnemyAng = atan2(enemyOffs.y, enemyOffs.x);
            double fromEnemyAng = atan2(-enemyOffs.y, -enemyOffs.x);

            // offset of self aim from enemy
            net.inputs[1] = DeltaAngle(MyZombie.angle, toEnemyAng) * NeuralNetwork.FIXUNIT / 100;

            // enemy health
            net.inputs[2] = MyZombie.target.health * NeuralNetwork.FIXUNIT / MyZombie.target.SpawnHealth();
            net.inputs[3] = (MyZombie.target.SpawnHealth() - MyZombie.target.health) * NeuralNetwork.FIXUNIT / MyZombie.target.SpawnHealth();

            // enemy visible
            net.inputs[4] = MyZombie.CheckSight(MyZombie.target) ? NeuralNetwork.FIXUNIT : 0;
            net.inputs[12] = MyZombie.CheckSight(MyZombie.target) ? 0 : NeuralNetwork.FIXUNIT;

            // enemy in self sights
            net.inputs[5] = 30 * NeuralNetwork.FIXUNIT / (8 + AbsAngle(MyZombie.angle, toEnemyAng) / 1.2);

            // self in enemy sights
            net.inputs[6] = 40 * NeuralNetwork.FIXUNIT / (10 + AbsAngle(MyZombie.target.angle, fromEnemyAng) / 1.5);

            // has enemy at all
            net.inputs[7] = NeuralNetwork.FIXUNIT;

            // distance and nearness from enemy
            net.inputs[10] = MyZombie.Distance2D(MyZombie.target) * NeuralNetwork.FIXUNIT / 1024;
            net.inputs[11] = (1024.0 / (500 + MyZombie.Distance2D(MyZombie.target)) * 1.5) * NeuralNetwork.FIXUNIT;

            // velocity (fast and slow, respectively)
            double velforce = sqrt((MyZombie.vel.x * MyZombie.vel.x) + (MyZombie.vel.y * MyZombie.vel.y));
            net.inputs[13] = velforce * NeuralNetwork.FIXUNIT / 5;
            net.inputs[14] = (8.0 / (1.0 + velforce)) * NeuralNetwork.FIXUNIT / 5;
        }

        // == lookAhead inputs
        inputLookAhead(net, 300, 16);
        inputLookAhead(net, 1200, 21);
    }

    private void inputLookAhead(NeuralNetwork net, double distance, int offset) {
        bool bWall;.
        bool bTarget;
        bool bFriend;
        double proximity;

        MyZombie.lookAhead(bWall, bTarget, bFriend, proximity, distance);
        
        net.inputs[offset] = (bWall ? NeuralNetwork.FIXUNIT : 0);
        net.inputs[offset + 1] = (bTarget ? NeuralNetwork.FIXUNIT : 0);
        net.inputs[offset + 2] = (bFriend ? NeuralNetwork.FIXUNIT : 0);
        net.inputs[offset + 3] = proximity * NeuralNetwork.FIXUNIT;
        net.inputs[offset + 4] = (1.0 - proximity) * NeuralNetwork.FIXUNIT;
    }

    override void applyOutputs(NeuralNetwork net) {
        // apply move
        double forward = net.outputs[1];
        double backward = net.outputs[2];
        double sideward = net.outputs[3];
        double resideward = net.outputs[4];

        double forward_x = cos(MyZombie.angle);
        double forward_y = sin(MyZombie.angle);

        if (abs(forward - backward) > NeuralNetwork.FIXUNIT / 5) {
            MyZombie.vel.x += forward_x * (forward - backward) / NeuralNetwork.FIXUNIT * 4;
            MyZombie.vel.y += forward_y * (forward - backward) / NeuralNetwork.FIXUNIT * 4;
        }

        if (abs(sideward - resideward) > NeuralNetwork.FIXUNIT / 7) {
            MyZombie.vel.x += forward_y * (sideward - resideward) / NeuralNetwork.FIXUNIT * 4;
            MyZombie.vel.y += -forward_x * (sideward - resideward) / NeuralNetwork.FIXUNIT * 4;
        }

        // apply turn
        MyZombie.angle += (net.outputs[0] - net.outputs[6]) * 9 / NeuralNetwork.FIXUNIT;

        // apply pitch
        double pitchMove = (net.outputs[8] - net.outputs[9]) * 1.0 / NeuralNetwork.FIXUNIT * 2;

        MyZombie.pitch += pitchMove;
        MyZombie.pitch -= MyZombie.pitch * 0.15; // soft lookspring

        // if applicable, fire!
        if (MyZombie.ready && net.outputs[5] > NeuralNetwork.FIXUNIT / 2) {
            MyZombie.SetStateLabel("Missile");
        }
    }

    override void setNet(NeuralNetwork newNet) {
        if (MyZombie.nnet != null) {
            MyZombie.nnet.Destroy();
        }
    
        MyZombie.nnet = newNet;
    }

    override Actor getActor() {
        return MyZombie;
    }

    override NNAgent reproduce() {
        GeneZombie NewZombie = MyZombie.Reproduce();

        if (NewZombie == null) {
            return null;
        }

        return NewZombie.agent;
    }
}

class ThruSpeciesBulletPuff : BulletPuff {
    default {
        +MTHRUSPECIES;
    }
}

class PopulationScoreboard {
    Array<GeneZombie> ranked;
    Array<double> fitnesses;

    bool IsSorted() {
        double earlier = fitnesses[0];
        int i = 1;

        while (i < fitnesses.Size()) {
            if (fitnesses[i] > earlier) {
                return false;
            }

            earlier = fitnesses[i];
            i++;
        }

        return true;
    }

    void UpdateFitnesses() {
        for (int i = 0; i < ranked.Size(); i++) {
            fitnesses[i] = ranked[i].fitness;
        }

        Sort();
    }

    void Sort() {
        bool sorted = false;

        while (!sorted) {
            sorted = true;

            for (int swapPos = 0; swapPos < fitnesses.Size() - 1; swapPos++) {
                double earlier = fitnesses[swapPos];

                if (earlier > fitnesses[swapPos + 1]) {
                    sorted = false; // more sorting may be necessary

                    fitnesses[swapPos] = fitnesses[swapPos + 1];
                    fitnesses[swapPos + 1] = earlier;

                    GeneZombie earlierVal = ranked[swapPos];
                    ranked[swapPos] = ranked[swapPos + 1];
                    ranked[swapPos + 1] = earlierVal;
                }
            }
        }
    }
}

class Vector3V {
    Vector3 val;

    Vector3 Get() {
        return val;
    }

    void Set(Vector3 newVal) {
        val = newVal;
    }

    static Vector3V Make(Vector3 val) {
        let v3v = Vector3V(New("Vector3V"));
        v3v.val = val;

        return v3v;
    }
}

class GenePopulation : Actor /* for A_Log */ {
    double averageFitness;
    int population;
    Array<GeneZombie> zombies;
    Array<Vector3V> spawnSpots;
    int generation;

    PopulationScoreboard scoreboard;
    
    // Hyperparameters
    int targetPop;
    float bredProportion;
    float survivalThreshold;

    void Init() {
        ChangeStatNum(STAT_INFO);

        averageFitness = 0;
        population = 0;
        generation = 1;
        scoreboard = New("PopulationScoreboard");

        // (set hyperparameter values here)
        targetPop = 100;
        survivalThreshold = 0.15;
        bredProportion = 0.75;
    }

    static GenePopulation Get() {
        ThinkerIterator it = ThinkerIterator.Create("GenePopulation", STAT_INFO);
        let p = GenePopulation(it.Next());

        if (p == null) {
            p = GenePopulation(Spawn("GenePopulation"));
            p.Init();
        }

        return p;
    }

    void RemoveZombie(GeneZombie zomb) {
        zombies.Delete(zombies.Find(zomb));
        
        int scoreIdx = scoreboard.ranked.Find(zomb);
        scoreboard.ranked.Delete(scoreIdx);
        scoreboard.fitnesses.Delete(scoreIdx);

        zomb.nnet.Destroy();
        zomb.Destroy();
    }

    void AddZombie(GeneZombie zomb) {
        scoreboard.ranked.Push(zomb);
        scoreboard.fitnesses.Push(zomb.fitness);
        //scoreboard.Sort();
    }

    void KillLivingZombies() {
        for (int i = 0; i < zombies.Size(); i++) {
            if (zombies[i].Health > 0) {
                zombies[i].Health = 0;
                // let ActivateBrain lead to the Death state;
                // don't jump to it now, otherwise it will
                // call UncountFromPop and mess things up
            }
        }
    }

    void CullUndesirable() {
        int cullIndex = scoreboard.ranked.Size() * survivalThreshold + 1;
    
        while (cullIndex < scoreboard.ranked.Size()) {
            RemoveZombie(scoreboard.ranked[cullIndex]);
        }
    }

    bool BreedNew() {
        int momIdx = Random(0, scoreboard.ranked.Size() * survivalThreshold);
        int dadIdx = Random(0, scoreboard.ranked.Size() * survivalThreshold);

        return NeuralNetwork.breed(scoreboard.ranked[momIdx].nnet, scoreboard.ranked[dadIdx].nnet) != null;
    }

    bool RandomNew() {
        if (spawnSpots.Size() == 0) {
            return false;
        }

        Vector3 spawnPos = spawnSpots[Random(0, spawnSpots.Size() - 1)].Get();

        Spawn("GeneZombie", spawnPos);

        return true;
    }

    void Repopulate() {
        if (population > targetPop * survivalThreshold && population > 0) {
            return;
        }

        generation += 1;

        //KillLivingZombies();

        scoreboard.UpdateFitnesses();
        CullUndesirable();

        int bredPop = targetPop * bredProportion;

        A_Log(
            String.Format("Repopulating zombies; generation %i is done (will breed %i more and create %i random)",
                generation,
                bredPop - population,
                targetPop - bredPop + (population >= 2 ? 0 : (2 - population)))
        );

        while (population < 2) {
            if (!RandomNew()) {
                A_Log("heck");
                return;
            }
        }

        while (population < bredPop) {
            if (!BreedNew()) {
                A_Log("heck");
                break;
            }
        }

        while (population < targetPop) {
            if (!RandomNew()) {
                A_Log("heck");
                break;
            }
        }
    }
}

class GeneZombie : ZombieMan {
    GeneZombieAgent agent;
    NeuralNetwork nnet;
    bool ready;
    bool firing;
    int lastTargetHealth;
    double fitness;
    bool counted;

    int hits;
    int selfDamage;
    double aimScore;
    double sightScore;

    private double lastFitness;
    private int lastSelfHealth;

    GenePopulation popInfo;
    

    default {
        +THRUSPECIES;
        +LOOKALLAROUND;
        +NOINFIGHTSPECIES;
        +FRIENDLY;
        Species "GeneZombie";
    }

    void lookAhead(out bool bWall, out bool bTarget, out bool bFriend, out double proximity, double distance = 1024) {
        FLineTraceData RemoteRay;
        bool hit = LineTrace(
           angle,
           distance,
           pitch,
           offsetz: height-12,
           data: RemoteRay
        );

        if (!hit) {
           return;
        }

        proximity = 1024.0 / (1024 + RemoteRay.Distance);
        proximity *= proximity * proximity;

        if (RemoteRay.HitType == TRACE_HitWall) {
            bWall = true;
        }

        else if (RemoteRay.HitType != TRACE_HitActor) {
            return;
        }

        if (GeneZombie(RemoteRay.HitActor) != null) {
            bFriend = true;
        }

        if (RemoteRay.HitActor == target && target != null) {
            bTarget = true;
        }
    }

    override void BeginPlay() {
        Super.BeginPlay();

        popInfo = GenePopulation.Get();
        popInfo.AddZombie(self);
        popInfo.spawnSpots.Push(Vector3V.Make(pos));

        fitness = 0.0;
        counted = true;
        lastFitness = 0.0;
        aimScore = 0.0;
        selfDamage = 0;
        hits = 0;
        lastTargetHealth = 0.0;
        firing = false;
        ready = false;

        agent = GeneZombieAgent.Make(self);

        if (nnet == null) {
            nnet = NeuralNetwork.Make(26, 10, 25, agent);

            int numNewConns = Random(5, 200);

            for (int i = 0; i < numNewConns; i++) {
                Connection conn = nnet.connectRandom();
                if (conn == null) continue;
            }

            // occasional defaults
            if (FRandom(0, 100) < 33) {
                // if enemy in sights, shoot
                nnet.connect(5 << 2 || NEU_INPUTS, 5 << 2 || NEU_OUTPUTS);
            }
        }

        RecountIntoPop();
    }

    private void updateFitness() {
        if (!counted) {
            return;
        }

        calcFitness();
        updateAvgFitness();
    }

    private void calcFitness() {
        fitness = hits * 2;
        fitness -= selfDamage / 2;
        fitness += aimScore;
        fitness += sightScore;
    }

    private void scoreDamage() {
        if (health != lastSelfHealth) {
            selfDamage += lastSelfHealth - health;
            lastSelfHealth = health;
        }
    }

    private void scoreSight() {
        if (target == null) {
            return;
        }
    
        if (!CheckSight(target)) {
            sightScore -= 0.07;
        }
    }

    private void scoreAim() {
        if (target == null) {
            return;
        }
    
        if (AbsAngle(angle, AngleTo(target)) < 20) {
            aimScore += 0.04;
        }

        else if (AbsAngle(angle, AngleTo(target)) > 90) {
            aimScore -= 0.01;
        }
    }

    private void updateAvgFitness() {
        if (fitness == lastFitness) {
            return;
        }

        //A_Log(String.Format("Delta fitness Df=%.2f from pop=%i update avg: %.2f + %.2f = %.2f", (fitness - lastFitness), popInfo.population, popInfo.averageFitness, (fitness - lastFitness) / popInfo.population, popInfo.averageFitness + (fitness - lastFitness) / popInfo.population));
        popInfo.averageFitness += (fitness - lastFitness) / popInfo.population;
        lastFitness = fitness;
    }

    void SelfState(int isReady, int isFiring = 0) {
        ready = isReady == 1;
        firing = isfiring == 1;
    }

    override void OnDestroy() {
        if (nnet != null) {
            nnet.Destroy();
        }
    }

    private void UncountFromPop() {
        popInfo.averageFitness -= fitness / popInfo.population;
        popInfo.population -= 1;
        counted = false;
        //popInfo.RemoveZombie(self);

        popInfo.Repopulate();
    }

    private void RecountIntoPop() {
        popInfo.population += 1;

        if (popInfo.population > 0) {        
            popInfo.averageFitness += fitness / popInfo.population;
        }

        else {
            popInfo.averageFitness = fitness;
        }

        counted = true;
        //popInfo.AddZombie(self);
    }

    void Remove() {
        SetStateLabel("Death");
        nnet.Destroy(); // prevent removed zombies from wasting memory

        // all removals are deaths, but not all deaths should be removals
        // (e.g. arch-vile can raise a GeneZombie if it was killed by others)
    }

    void ActivateBrain() {
        if (health <= 0) {
            SetStateLabel("Death");
            return;
        }
    
        if (nnet == null) {
            return;
        }
    
        if (!ready) {
            return;
        }

        nnet.update();

        scoreAim(); 
        scoreSight();
        scoreDamage();

        updateFitness();

        // lifetime
        if (Random(0, 15) > 0) {
            return;
        }

        health -= 1;
        lastSelfHealth -= 1;

        if (health <= 0) {
            SetStateLabel("Death");
            return;

            /* -- old mitosis code

            // when dying out, there's a chance to reproduce
            A_Log(String.Format("Final fitness: %.2f (average: %.2f)", fitness, popInfo.averageFitness));

            if (fitness < popInfo.averageFitness) {
                // no replicate
                Remove();
                return;
            }

            int replicas = log(1.0 + (fitness - popInfo.averageFitness) / 2.0);
            for (int i = 0; i < replicas; i++) {
                NeuralNetwork replicated = nnet.replicate();
            }

            Remove();
            return;

            */
        }
    }

    void CheckTargetHealth() {
        lastTargetHealth = target.health;
    }

    GeneZombie Reproduce() {
        GeneZombie newZombie;

        if (popInfo != null && popInfo.spawnSpots.Size() > 0) {
            Vector3 spawnPos = popInfo.spawnSpots[Random(0, popInfo.spawnSpots.Size() - 1)].Get();

            newZombie = GeneZombie(Spawn("GeneZombie", spawnPos));
        }

        else {
            Vector3 SpawnOffs;

            double spawnang = FRandom(0, 360);
            double spawndist = FRandom(radius * 2, 220);
            SpawnOffs.x = cos(spawnang) * spawndist;
            SpawnOffs.y = sin(spawnang) * spawndist;
            
            newZombie = GeneZombie(Spawn("GeneZombie", pos + SpawnOffs));
        }

        if (newZombie == null) {
            return null;
        }

        if (newZombie.nnet != null) {
            newZombie.nnet.Destroy();
        }

        newZombie.target = target;
        newZombie.angle = FRandom(0, 360);

        return newZombie;
    }

    void CheckReplicate() {
        if (target == null) {
            return;
        }

        int damage = lastTargetHealth - target.health;

        if (damage <= 0) {
            return;
        }

        hits += 1;
        updateFitness();
    }

    states {
        See:
            POSS A 0 SelfState(1);
            goto SeeLoop;

        SeeLoop:
            POSS AABBCCDD 4 ActivateBrain;
            loop;

        Missile:
            POSS E 0 SelfState(0, 1);
            POSS EE 4 ActivateBrain;

            POSS F 0 CheckTargetHealth;
            POSS F 0 A_CustomBulletAttack(4.5, 0, 1, random(1,5)*3, "ThruSpeciesBulletPuff", 0, CBAF_NORANDOM | CBAF_AIMFACING);
            POSS F 0 CheckReplicate;

            POSS FF 3 ActivateBrain;
            POSS EE 3 ActivateBrain;
            goto See;

        Death:
            POSS M 0 SelfState(0);
            POSS M 0 UncountFromPop;
            goto Super::Death;

        XDeath:
            POSS H 0 SelfState(0);
            POSS H 0 UncountFromPop;
            goto Super::XDeath;

        Raise:
            POSS K 0 RecountIntoPop;
            goto Super::Raise;
    }
}
