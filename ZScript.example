#include "zgenet.zsc"

class GeneZombieAgent : NNAgent {
    GeneZombie MyZombie;
    int age;

    static GeneZombieAgent Make(GeneZombie owner) {
        GeneZombieAgent agent = GeneZombieAgent(Spawn("GeneZombieAgent"));
    
        agent.MyZombie = owner;

        return agent;
    }

    //=====

    override void refreshInputs(NeuralNetwork net) {
        net.inputs[0] = MyZombie.health * NeuralNetwork.FIXUNIT / MyZombie.SpawnHealth();

        double ageval = age;
        ageval /= 80.0;

        // oscillator neurons
        net.inputs[8] = sin(ageval) * NeuralNetwork.FIXUNIT;
        net.inputs[9] = sin(ageval / 8) * NeuralNetwork.FIXUNIT;

        // am firing?
        net.inputs[15] = (MyZombie.firing ? NeuralNetwork.FIXUNIT : 0);
        
        if (MyZombie.target == null) {
            net.inputs[1] = 0;

            net.inputs[2] = 0;
            net.inputs[3] = 0;

            net.inputs[4] = 0;
            net.inputs[12] = 0;

            net.inputs[5] = 0;
            net.inputs[6] = 0;

            net.inputs[7] = 0;

            net.inputs[10] = 0;
            net.inputs[11] = 0;
        }

        else {
            Vector2 enemyOffs = MyZombie.Vec2To(MyZombie.target);
            double toEnemyAng = atan2(enemyOffs.y, enemyOffs.x);
            double fromEnemyAng = atan2(-enemyOffs.y, -enemyOffs.x);

            // offset of self aim from enemy
            net.inputs[1] = DeltaAngle(MyZombie.angle, toEnemyAng) * NeuralNetwork.FIXUNIT / 100;

            // enemy health
            net.inputs[2] = MyZombie.target.health * NeuralNetwork.FIXUNIT / MyZombie.target.SpawnHealth();
            net.inputs[3] = (MyZombie.target.SpawnHealth() - MyZombie.target.health) * NeuralNetwork.FIXUNIT / MyZombie.target.SpawnHealth();

            // enemy visible
            net.inputs[4] = MyZombie.CheckSight(MyZombie.target) ? NeuralNetwork.FIXUNIT : 0;
            net.inputs[12] = MyZombie.CheckSight(MyZombie.target) ? 0 : NeuralNetwork.FIXUNIT;

            // enemy in self sights
            net.inputs[5] = 30 * NeuralNetwork.FIXUNIT / (8 + AbsAngle(MyZombie.angle, toEnemyAng) / 1.2);

            // self in enemy sights
            net.inputs[6] = 40 * NeuralNetwork.FIXUNIT / (10 + AbsAngle(MyZombie.target.angle, fromEnemyAng) / 1.5);

            // has enemy at all
            net.inputs[7] = NeuralNetwork.FIXUNIT;

            // distance and nearness from enemy
            net.inputs[10] = MyZombie.Distance2D(MyZombie.target) * NeuralNetwork.FIXUNIT / 1024;
            net.inputs[11] = (1024.0 / (500 + MyZombie.Distance2D(MyZombie.target)) * 1.5) * NeuralNetwork.FIXUNIT;

            // velocity (fast and slow, respectively)
            double velforce = sqrt((MyZombie.vel.x * MyZombie.vel.x) + (MyZombie.vel.y * MyZombie.vel.y));
            net.inputs[13] = velforce * NeuralNetwork.FIXUNIT / 5;
            net.inputs[14] = (8.0 / (1.0 + velforce)) * NeuralNetwork.FIXUNIT / 5;
        }

        // == lookAhead inputs
        inputLookAhead(net, 300, 16);
        inputLookAhead(net, 1200, 21);
    }

    private void inputLookAhead(NeuralNetwork net, double distance, int offset) {
        bool bWall;.
        bool bTarget;
        bool bFriend;
        double proximity;

        MyZombie.lookAhead(bWall, bTarget, bFriend, proximity, distance);
        
        net.inputs[offset] = (bWall ? NeuralNetwork.FIXUNIT : 0);
        net.inputs[offset + 1] = (bTarget ? NeuralNetwork.FIXUNIT : 0);
        net.inputs[offset + 2] = (bFriend ? NeuralNetwork.FIXUNIT : 0);
        net.inputs[offset + 3] = proximity * NeuralNetwork.FIXUNIT;
        net.inputs[offset + 4] = (1.0 - proximity) * NeuralNetwork.FIXUNIT;
    }

    override void applyOutputs(NeuralNetwork net) {
        //A_Log("Net inputs: "..net.inputs[0].." "..net.inputs[1].." "..net.inputs[2].." "..net.inputs[3].." "..net.inputs[4].." "..net.inputs[5].." "..net.inputs[6].." "..net.inputs[7].." "..net.inputs[8].." "..net.inputs[9].." "..net.inputs[10].." "..net.inputs[11].." "..net.inputs[12]);
        //A_Log("Net outputs: "..net.outputs[0].." "..net.outputs[1].." "..net.outputs[2].." "..net.outputs[3].." "..net.outputs[4].." "..net.outputs[5]);
        //A_Log("Some net hiddens: "..net.hidden[0].." "..net.hidden[1].." "..net.hidden[2].." "..net.hidden[3].." "..net.hidden[4].." "..net.hidden[5].." "..net.hidden[6].." "..net.hidden[7].." "..net.hidden[8]);

        double forward = net.outputs[1];
        double backward = net.outputs[2];
        double sideward = net.outputs[3];
        double resideward = net.outputs[4];

        double forward_x = cos(MyZombie.angle);
        double forward_y = sin(MyZombie.angle);

        if (abs(forward - backward) > NeuralNetwork.FIXUNIT / 5) {
            MyZombie.vel.x += forward_x * (forward - backward) / NeuralNetwork.FIXUNIT * 4;
            MyZombie.vel.y += forward_y * (forward - backward) / NeuralNetwork.FIXUNIT * 4;
        }

        if (abs(sideward - resideward) > NeuralNetwork.FIXUNIT / 7) {
            MyZombie.vel.x += forward_y * (sideward - resideward) / NeuralNetwork.FIXUNIT * 4;
            MyZombie.vel.y += -forward_x * (sideward - resideward) / NeuralNetwork.FIXUNIT * 4;
        }

        //A_Log("zombie velocity:  "..MyZombie.vel.x.."  "..MyZombie.vel.y);

        MyZombie.angle += (net.outputs[0] - net.outputs[6]) * 9 / NeuralNetwork.FIXUNIT;

        if (MyZombie.ready && net.outputs[5] > NeuralNetwork.FIXUNIT / 2) {
            MyZombie.SetStateLabel("Missile");
        }
    }

    override void setNet(NeuralNetwork newNet) {
        if (MyZombie.nnet != null) {
            MyZombie.nnet.Destroy();
        }
    
        MyZombie.nnet = newNet;
    }

    override Actor getActor() {
        return MyZombie;
    }

    override NNAgent reproduce() {
        GeneZombie NewZombie = MyZombie.Reproduce();

        if (NewZombie == null) {
            return null;
        }

        return NewZombie.agent;
    }
}

class ThruSpeciesBulletPuff : BulletPuff {
    default {
        +MTHRUSPECIES;
    }
}

class GeneZombiePopulation : Thinker {
    double averageFitness;
    int population;

    GeneZombiePopulation Init() {
        ChangeStatNum(STAT_INFO);
        averageFitness = 0;
        population = 0;
        return self;
    }

    static GeneZombiePopulation Get() {
        ThinkerIterator it = ThinkerIterator.Create("GeneZombiePopulation", STAT_INFO);
        let p = GeneZombiePopulation(it.Next());

        if (p == null) {
            p = new("GeneZombiePopulation").Init();
        }

        return p;
    }
}

class GeneZombie : ZombieMan {
    GeneZombieAgent agent;
    NeuralNetwork nnet;
    bool ready;
    bool firing;
    int lastTargetHealth;
    double fitness;
    bool counted;

    int hits;
    double aimScore;
    double sightScore;

    double _lastFitness;

    GeneZombiePopulation popInfo;
    

    default {
        +THRUSPECIES;
        +LOOKALLAROUND;
        +NOINFIGHTSPECIES;
        Species "GeneZombie";
    }

    void lookAhead(out bool bWall, out bool bTarget, out bool bFriend, out double proximity, double distance = 1024) {
        FLineTraceData RemoteRay;
        bool hit = LineTrace(
           angle,
           distance,
           pitch,
           offsetz: height-12,
           data: RemoteRay
        );

        if (!hit) {
           return;
        }

        proximity = 1024.0 / (1024 + RemoteRay.Distance);
        proximity *= proximity * proximity;

        if (RemoteRay.HitType == TRACE_HitWall) {
            bWall = true;
        }

        else if (RemoteRay.HitType != TRACE_HitActor) {
            return;
        }

        if (GeneZombie(RemoteRay.HitActor) != null) {
            bFriend = true;
        }

        if (RemoteRay.HitActor == target && target != null) {
            bTarget = true;
        }
    }

    override void PostBeginPlay() {
        Super.PostBeginPlay();

        popInfo = GeneZombiePopulation.Get();

        fitness = 0.0;
        counted = true;
        _lastFitness = 0.0;
        aimScore = 0.0;
        hits = 0;
        lastTargetHealth = 0.0;
        firing = false;
        ready = false;

        agent = GeneZombieAgent.Make(self);

        if (nnet == null) {
            nnet = NeuralNetwork.Make(26, 7, 25, agent);

            int numNewConns = Random(5, 200);

            for (int i = 0; i < numNewConns; i++) {
                Connection conn = nnet.connectRandom();
                if (conn == null) continue;
            }

            // occasional defaults
            if (FRandom(0, 100) < 33) {
                // if enemy in sights, shoot
                nnet.connect(5 << 2 || NEU_INPUTS, 5 << 2 || NEU_OUTPUTS);
            }
        }

        popInfo.averageFitness *= 1.0 * popInfo.population / (popInfo.population + 1);
        popInfo.population += 1;
    }

    private void updateFitness() {
        if (!counted) {
            return;
        }

        calcFitness();
        updateAvgFitness();
    }

    private void calcFitness() {
        fitness = hits * 5;
        fitness += health / 2;
        fitness += aimScore;
        fitness += sightScore;
    }

    private void scoreSight() {
        if (target == null) {
            return;
        }
    
        if (!CheckSight(target)) {
            sightScore -= 0.07;
        }
    }

    private void scoreAim() {
        if (target == null) {
            return;
        }
    
        if (AbsAngle(angle, AngleTo(target)) < 20) {
            aimScore += 0.04;
        }

        else if (AbsAngle(angle, AngleTo(target)) > 90) {
            aimScore -= 0.01;
        }
    }

    private void updateAvgFitness() {
        if (fitness == _lastFitness) {
            return;
        }

        //A_Log(String.Format("Delta fitness Df=%.2f from pop=%i update avg: %.2f + %.2f = %.2f", (fitness - _lastFitness), popInfo.population, popInfo.averageFitness, (fitness - _lastFitness) / popInfo.population, popInfo.averageFitness + (fitness - _lastFitness) / popInfo.population));
        popInfo.averageFitness += (fitness - _lastFitness) / popInfo.population;
        _lastFitness = fitness;
    }

    void SelfState(int isReady, int isFiring = 0) {
        ready = isReady == 1;
        firing = isfiring == 1;
    }

    override void OnDestroy() {
        if (nnet != null) {
            nnet.Destroy();
        }
    }

    private void UncountFromPop() {
        popInfo.averageFitness -= fitness / popInfo.population;
        popInfo.population -= 1;
        counted = false;
    }

    private void RecountIntoPop() {
        popInfo.population += 1;
        popInfo.averageFitness += fitness / popInfo.population;
        counted = true;
    }

    void Remove() {
        SetStateLabel("Death");
        nnet.Destroy(); // prevent removed zombies from wasting memory

        // all removals are deaths, but not all deaths should be removals
        // (e.g. arch-vile can raise a GeneZombie if it was killed by others)
    }

    void ActivateBrain() {
        if (nnet == null) {
            return;
        }
    
        if (!ready) {
            return;
        }

        nnet.update();

        scoreAim(); 
        updateFitness();

        // lifetime
        if (Random(0, 15) > 0) {
            return;
        }

        health -= 1;

        if (health <= 0) {
            // when dying out, there's a chance to reproduce
            A_Log(String.Format("Final fitness: %.2f (average: %.2f)", fitness, popInfo.averageFitness));

            if (fitness < popInfo.averageFitness) {
                // no replicate
                Remove();
                return;
            }

            int replicas = log(1.0 + (fitness - popInfo.averageFitness) / 2.0);
            for (int i = 0; i < replicas; i++) {
                NeuralNetwork replicated = nnet.replicate();
            }

            Remove();
            return;
        }
    }

    void CheckTargetHealth() {
        lastTargetHealth = target.health;
    }

    GeneZombie Reproduce() {
        Vector3 SpawnOffs;

        double spawnang = FRandom(0, 360);
        double spawndist = FRandom(radius * 2, 220);
        SpawnOffs.x = cos(spawnang) * spawndist;
        SpawnOffs.y = sin(spawnang) * spawndist;
        
        GeneZombie newZombie = GeneZombie(Spawn("GeneZombie", pos + SpawnOffs));

        if (newZombie == null) {
            return null;
        }

        if (newZombie.nnet != null) {
            newZombie.nnet.Destroy();
        }

        newZombie.target = target;
        newZombie.angle = angle;

        return newZombie;
    }

    void CheckReplicate() {
        if (target == null) {
            return;
        }

        int damage = lastTargetHealth - target.health;

        if (damage <= 0) {
            return;
        }

        hits += 1;
        updateFitness();
    }

    states {
        See:
            POSS A 0 SelfState(1);
            goto SeeLoop;

        SeeLoop:
            POSS AABBCCDD 4 ActivateBrain;
            loop;

        Missile:
            POSS E 0 SelfState(0, 1);
            POSS EE 4 ActivateBrain;

            POSS F 0 CheckTargetHealth;
            POSS F 0 A_CustomBulletAttack(4.5, 0, 1, random(1,5)*3, "ThruSpeciesBulletPuff", 0, CBAF_NORANDOM | CBAF_AIMFACING);
            POSS F 0 CheckReplicate;

            POSS FF 3 ActivateBrain;
            POSS EE 3 ActivateBrain;
            goto See;

        Death:
            POSS M 0 SelfState(0);
            POSS M 0 UncountFromPop;
            goto Super::Death;

        XDeath:
            POSS H 0 SelfState(0);
            POSS H 0 UncountFromPop;
            goto Super::XDeath;

        Raise:
            POSS K 0 RecountIntoPop;
            goto Super::Raise;
    }
}
