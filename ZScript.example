#include "zgenet.zs"

class GeneZombieAgent : NNAgent {
    GeneZombie MyZombie;
    int age;

    static GeneZombieAgent Make(GeneZombie owner) {
        GeneZombieAgent agent = GeneZombieAgent(Spawn("GeneZombieAgent"));
    
        agent.MyZombie = owner;

        return agent;
    }

    //=====

    override void refreshInputs(NeuralNetwork net) {
        net.inputs[0] = MyZombie.health * NeuralNetwork.FIXUNIT / MyZombie.SpawnHealth();

        double ageval = age;
        ageval /= 80.0;

        // oscillator neurons
        net.inputs[8] = sin(ageval) * NeuralNetwork.FIXUNIT;
        net.inputs[9] = sin(ageval / 8) * NeuralNetwork.FIXUNIT;
        
        if (MyZombie.target == null) {
            net.inputs[1] = 0;

            net.inputs[2] = 0;
            net.inputs[3] = 0;

            net.inputs[4] = 0;
            net.inputs[12] = 0;

            net.inputs[5] = 0;
            net.inputs[6] = 0;

            net.inputs[7] = 0;

            net.inputs[10] = 0;
            net.inputs[11] = 0;
        }

        else {
            Vector2 enemyOffs = MyZombie.Vec2To(MyZombie.target);
            double toEnemyAng = atan2(enemyOffs.y, enemyOffs.x);
            double fromEnemyAng = atan2(-enemyOffs.y, -enemyOffs.x);

            // offset of self aim from enemy
            net.inputs[1] = DeltaAngle(MyZombie.angle, toEnemyAng) * NeuralNetwork.FIXUNIT / 100;

            // enemy health
            net.inputs[2] = MyZombie.target.health * NeuralNetwork.FIXUNIT / MyZombie.target.SpawnHealth();
            net.inputs[3] = (MyZombie.target.SpawnHealth() - MyZombie.target.health) * NeuralNetwork.FIXUNIT / MyZombie.target.SpawnHealth();

            // enemy visible
            net.inputs[4] = MyZombie.CheckSight(MyZombie.target) ? NeuralNetwork.FIXUNIT : 0;
            net.inputs[12] = MyZombie.CheckSight(MyZombie.target) ? 0 : NeuralNetwork.FIXUNIT;

            // enemy in self sights
            net.inputs[5] = 30 * NeuralNetwork.FIXUNIT / (8 + AbsAngle(MyZombie.angle, toEnemyAng) / 1.2);

            // self in enemy sights
            net.inputs[6] = 40 * NeuralNetwork.FIXUNIT / (10 + AbsAngle(MyZombie.target.angle, fromEnemyAng) / 1.5);

            // has enemy at all
            net.inputs[7] = NeuralNetwork.FIXUNIT;

            // distance and nearness from enemy
            net.inputs[10] = MyZombie.Distance2D(MyZombie.target) * NeuralNetwork.FIXUNIT / 1024;
            net.inputs[11] = (1024.0 / (500 + MyZombie.Distance2D(MyZombie.target)) * 1.5) * NeuralNetwork.FIXUNIT;

            // velocity (fast and slow, respectively)
            double velforce = sqrt((MyZombie.vel.x * MyZombie.vel.x) + (MyZombie.vel.y * MyZombie.vel.y));
            net.inputs[13] = velforce * NeuralNetwork.FIXUNIT / 5;
            net.inputs[14] = (8.0 / (1.0 + velforce)) * NeuralNetwork.FIXUNIT / 5;
        }
    }

    override void applyOutputs(NeuralNetwork net) {
        //A_Log("Net inputs: "..net.inputs[0].." "..net.inputs[1].." "..net.inputs[2].." "..net.inputs[3].." "..net.inputs[4].." "..net.inputs[5].." "..net.inputs[6].." "..net.inputs[7].." "..net.inputs[8].." "..net.inputs[9].." "..net.inputs[10].." "..net.inputs[11].." "..net.inputs[12]);
        //A_Log("Net outputs: "..net.outputs[0].." "..net.outputs[1].." "..net.outputs[2].." "..net.outputs[3].." "..net.outputs[4].." "..net.outputs[5]);
        //A_Log("Some net hiddens: "..net.hidden[0].." "..net.hidden[1].." "..net.hidden[2].." "..net.hidden[3].." "..net.hidden[4].." "..net.hidden[5].." "..net.hidden[6].." "..net.hidden[7].." "..net.hidden[8]);

        double forward = net.outputs[1];
        double backward = net.outputs[2];
        double sideward = net.outputs[3];
        double resideward = net.outputs[4];

        double forward_x = cos(MyZombie.angle);
        double forward_y = sin(MyZombie.angle);

        if (abs(forward - backward) > NeuralNetwork.FIXUNIT / 5) {
            MyZombie.vel.x += forward_x * (forward - backward) / NeuralNetwork.FIXUNIT * 4;
            MyZombie.vel.y += forward_y * (forward - backward) / NeuralNetwork.FIXUNIT * 4;
        }

        if (abs(sideward - resideward) > NeuralNetwork.FIXUNIT / 7) {
            MyZombie.vel.x += forward_y * (sideward - resideward) / NeuralNetwork.FIXUNIT * 4;
            MyZombie.vel.y += -forward_x * (sideward - resideward) / NeuralNetwork.FIXUNIT * 4;
        }

        //A_Log("zombie velocity:  "..MyZombie.vel.x.."  "..MyZombie.vel.y);

        MyZombie.angle += (net.outputs[0] - net.outputs[6]) * 9 / NeuralNetwork.FIXUNIT;

        if (MyZombie.ready && net.outputs[5] > NeuralNetwork.FIXUNIT / 2) {
            MyZombie.SetStateLabel("Missile");
        }
    }

    override void setNet(NeuralNetwork newNet) {
        if (MyZombie.nnet != null) {
            MyZombie.nnet.Destroy();
        }
    
        MyZombie.nnet = newNet;
    }

    override Actor getActor() {
        return MyZombie;
    }

    override NNAgent reproduce() {
        GeneZombie NewZombie = MyZombie.Reproduce();

        if (NewZombie == null) {
            return null;
        }

        return NewZombie.agent;
    }
}

class ThruSpeciesBulletPuff : BulletPuff {
    default {
        +MTHRUSPECIES;
    }
}

class GeneZombie : ZombieMan {
    GeneZombieAgent agent;
    NeuralNetwork nnet;
    bool ready;
    int lastTargetHealth;
    double fitness;
    double offspringQuota;

    default {
        +THRUSPECIES;
        +LOOKALLAROUND;
        +NOINFIGHTSPECIES;
        Species "GeneZombie";
    }

    override void PostBeginPlay() {
        Super.PostBeginPlay();

        agent = GeneZombieAgent.Make(self);
        fitness = 0.0;
        lastTargetHealth = 0.0;
        ready = false;

        if (nnet == null) {
            nnet = NeuralNetwork.Make(15, 7, 25, agent);

            int numNewConns = Random(5, 200);

            for (int i = 0; i < numNewConns; i++) {
                Connection conn = nnet.connectRandom();
                if (conn == null) continue;
            }

            // occasional defaults
            if (FRandom(0, 100) < 33) {
                // if enemy in sights, shoot
                nnet.connect(5 << 2 || NEU_INPUTS, 5 << 2 || NEU_OUTPUTS);
            }

            if (FRandom(0, 100) < 15) {
                // if enemy far, walk
                nnet.connect(10 << 2 || NEU_INPUTS, 1 << 2 || NEU_OUTPUTS);
            }
        }
    }

    void SelfState(int isReady) {
        ready = isReady == 1;
    }

    override void OnDestroy() {
        if (nnet != null) {
            nnet.Destroy();
        }
    }

    void ActivateBrain() {
        if (nnet == null) {
            return;
        }
    
        if (!ready) {
            return;
        }

        nnet.update();

        // lifetime
        if (Random(0, 15) > 0) {
            return;
        }

        health -= 1;

        if (health <= 0) {
            SetStateLabel("Death");

            // when dying out, there's a chance to reproduce
            double repliChance = 1.0 / (1.0 + log(1.0 + fitness / 1.5));

            if (FRandom(0, 2.0) > repliChance) {
                // no replicate
                nnet.Destroy(); // prevent died-out zombies from wasting memory
                return;
            }

            int replicas = Random(3, 9);
            for (int i = 0; i < replicas; i++) {
                nnet.replicate();
            }

            nnet.Destroy(); // prevent died-out zombies from wasting memory
            return;
        }

        if (fitness < 1) {
            fitness += 0.01;
        }

        else if (fitness > 1) {
            fitness -= 0.015;
        }

        // some other things that would be nice to have in zombies
        if (target == null) {
            return;
        }

        if (AbsAngle(angle, AngleTo(target)) < 15) {
            fitness += 0.2;
        }

        if (Distance2D(target) < 384) {
            fitness += 0.05;
        }

        if (Distance2D(target) > 1024) {
            fitness -= 0.02;
        }
    }

    void CheckTargetHealth() {
        lastTargetHealth = target.health;
    }

    GeneZombie Reproduce() {
        Vector3 SpawnOffs;

        double spawnang = FRandom(0, 360);
        double spawndist = FRandom(radius * 2, 220);
        SpawnOffs.x = cos(spawnang) * spawndist;
        SpawnOffs.y = sin(spawnang) * spawndist;
        
        GeneZombie newZombie = GeneZombie(Spawn("GeneZombie", pos + SpawnOffs));

        if (newZombie == null) {
            return null;
        }

        if (newZombie.nnet != null) {
            newZombie.nnet.Destroy();
        }

        newZombie.target = target;
        newZombie.angle = angle;

        return newZombie;
    }

    void CheckReplicate() {
        if (target == null) {
            return;
        }

        int damage = lastTargetHealth - target.health;

        if (damage <= 0) {
            return;
        }

        fitness += damage;
    }

    states {
        See:
            POSS A 0 SelfState(1);
            goto SeeLoop;

        SeeLoop:
            POSS AABBCCDD 4 ActivateBrain;
            loop;

        Missile:
            POSS E 0 SelfState(0);
            POSS EE 4 ActivateBrain;

            POSS F 0 CheckTargetHealth;
            POSS F 0 A_CustomBulletAttack(4.5, 0, 1, random(1,5)*3, "ThruSpeciesBulletPuff", 0, CBAF_NORANDOM | CBAF_AIMFACING);
            POSS F 0 CheckReplicate;

            POSS FF 3 ActivateBrain;
            POSS EE 3 ActivateBrain;
            goto See;

        Death:
            POSS M 0 SelfState(0);
            goto Super::Death;

        XDeath:
            POSS H 0 SelfState(0);
            goto Super::XDeath;
    }
}
